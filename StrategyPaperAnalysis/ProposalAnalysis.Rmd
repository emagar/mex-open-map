---
title: "Proposal Analysis"
output:
  pdf_document: default
  html_document:
    df_print: paged
  html_notebook: default
---

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Description: This notebook file was created by A. Trelles on 12/28/19 as part of the Strategy Paper. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#General Description:
This analysis is used as a reference to write the code for the analysis of partisan counterporposals for the 2013 and 2017 redistricting process in relation with partisan ruling status, its strenght (vote returns), and state level coalition dynamics.  

The first part of the ProposalAnalysis.Rmd IS NOT CODE. It describes the general objectives of the analysis based on the hypotheses derived from the paper and the available data we have to test them. In all cases, the DV is related to a partyÂ´s decision to formulate a counterporposal. 

General Hypotheses H1, H2, and H3 assume the DV is if a party formulated a counterporposal,
and vary according the ruling party (H1), party strenght/vote returns (H2), and coalitions (H3). 


// Setup //

#Libraries
```{r message=FALSE}
require(tidyverse)
require(magrittr)
require(tidylog)
require(fastDummies)
require(tidymodels)
require(gt)
require(car)
require(lmtest)
require(ordinal)
require(rcompanion)
require(caret)
require(readxl)
```
#bring in Data
```{r include=FALSE}
source("PrepData.R")
```



Generate data frame for testing entry decisions.

Data frame: ys.proposed

Main unit of analysis: (party BY state AND year) -- summarize the actions each party took for each state in year -- NOT individual proposals

Measures (aggregated by STATE and YEAR )

- numproposals - number of proposals made by  party
- didPropose -  logical - whether party made any propoals -dummy variable derived from number of proposals > 0
- didControl - logical - whether party was in sole control of the state for the entire relevant period , derived from (control)
- didRule - logical whether party was in power at the end of the period, while redistricting takes place
- didWinever - party was in control at least once  during the period


State-level measures inherited from controlByWindow()
- partylist, partyseq, partytab, singlecontrol, percentsingle, primary, secondary, tertiary
State-level measures added:
- singlecontrol - dummy, where singlecontrol != NONE
NOTE: these  are measures of the STATE at that time, not specific to party
- partylist - names of parties in control of state over the relevant prior period, names may repeat if party control cycles back and forth
- year_2017 - indicator if year is 2017, based on (year)
- ruleparty - name of party that was in control at last year of period

```{r}
#Code generating needed variables
ys.proposed <- propfull.df %>% group_by(actor,edon,year) %>% summarise(numproposals=sum(PROPOSED,na.rm=TRUE))
#output <- propstrue(proposals.df)
ys.control <- grule.df %>%  controlByWindow(2000,2013)%>%  mutate (edon=edon, year=2013,control=if_else(singlecontrol,primary,"NONE"))
ys.control %<>% bind_rows (grule.df %>%  controlByWindow(2000,2017) %>% mutate(edon=edon, year=2017,control=if_else(singlecontrol,primary,"NONE")))
ys.proposed %<>% left_join(ys.control)
rm(ys.control)
ys.proposed %<>% rowwise() %>% mutate(didPropose=(numproposals>0),didControl=(actor==control))
ys.proposed %<>% rowwise() %>% mutate(year_2017 = ifelse(year == 2017, 1, 0))
ys.proposed %<>% rowwise() %>% mutate(ruleparty = tail(partylist,1)) 
ys.proposed %<>% rowwise() %>% mutate(didRule=(actor==ruleparty))
ys.proposed %<>% rowwise() %>% mutate(didWinever=(actor %in% partylist))

ys.proposed %>% ggplot(aes(control,numproposals))+geom_boxplot()+facet_grid(rows=vars(year))


# join with parties
ys.proposed %<>% left_join(actors.df)

```
Strategic Position Categorization

A party in a "strong" position political position in the state, then they are more likely to propose than a party with a less "strong" position.

The decision is a function of several variables such as: party controls the state during the redistricting year, if the party has been the sole ruler over from 1990-2013/17, and if they have ruled a majority of that timer period, if they have ruled at least once during that time period. 

The variables used in the decision tree embody levels of competition in each state. A state controlled by a single party during the period has low levels of political competition, for example. A state with a party which has not won a majority of elections but has won at least once has some degree of power in a competitive state (there are at least two parties competing), as another example. The former has a better "strategic position" than the latter. 

The "Strategic Positions" are defined as follows:
1. Party a) Controls during redistricting year b) has controlled state in all previous observed periods

2. Party a) Controls during redistricting year b) has NOT controlled state in all previously observed periods

3. Party a) DOES NOT control during the redistricting year b) has NOT controlled state in all previously observed periods c) has won a MAJORITY of previous elections in observed time period

4. Party a) DOES NOT control during the redistricting year b) has NOT controlled state in all previously observed periods c) has won a MINORITY of previous elections in observed time period

5.  Party a) DOES NOT control during the redistricting year b) has NOT controlled state in all previously observed periods c) has won NONE of the previous elections during the time period

6. Party a) DOES NOT control during the redistricting year b) has NOT controlled state in all previously observed periods c) has won NONE of the previous elections during the time period d) another party has won ALL previous elections
```{r}

ys.proposed %<>% rowwise() %>% mutate(
    PartyStratPos = case_when(
      didControl == TRUE     ~ 1, # in sole control entire period
      didRule == TRUE        ~ 2, # NOT in sole control, but won last election
      actor == primary       ~ 3, # NOT win last election, but won most elections
      didWinever == TRUE     ~ 4, # NOT won most, but won at least one
      singlecontrol == FALSE ~ 5, # NOT won ever,  but single party does not control
      TRUE ~ 6 # Out party in noncompetitive state  - different party always in control
    )
  )


table(ys.proposed$PartyStratPos)
check.df <- ys.proposed %>% filter(PartyStratPos == 6)
table(check.df$edon)


# now compute for coalitions
coalitions.df <- read_excel("coalition-data/Coaltion Data State Level 2010-2016 (Coalitions and Parties).xlsx")
coalitions.df %<>% rowwise() %>% filter(grepl('-',actor)) %>% mutate(coalition=actor) %>% separate_rows(actor,sep='-')

coalitions.df %<>% left_join(select(ys.proposed,c("actor","edon","year","PartyStratPos"))) %>% group_by(edon,year,coalition) %>% mutate(CoalitionStratPos=min(PartyStratPos)) %>% select(-PartyStratPos)

ys.proposed %<>% left_join(coalitions.df,by=c("actor","edon","year"))

ys.proposed %<>% mutate(StratPos=if_else(is.na(CoalitionStratPos),PartyStratPos,CoalitionStratPos))
ys.proposed %<>% mutate(inCoalition=ifelse(CoalitionStratPos > 0, 1, 0))
ys.proposed %<>% mutate(didPropose.num = as.numeric(didPropose))
ys.proposed %<>% filter(actortype == "minor" || actortype == "major")
table(as.factor(ys.proposed$actor))

#check pattern of proposal entry
xtab.result <- ys.proposed %>% filter(actortype=="minor" || actortype=="major") %>% xtabs(~actortype+year+didPropose+StratPos,.,drop.unused.levels = TRUE)
ftable(xtab.result)

#gt(ftable(xtab.result))

```


```{r}
#CLM model first
clm.mod <- ys.proposed %>% clm(as.ordered(didPropose)~as.ordered(PartyStratPos), data=., HESS=TRUE)
summary(clm.mod)
confint(clm.mod)
exp(coef(clm.mod)[2])
exp(coef(clm.mod)[3]) 
exp(coef(clm.mod)[4])
exp(coef(clm.mod)[5])
exp(coef(clm.mod)[6])
ys.proposed %>% ggplot(aes(didPropose)) + geom_bar() +facet_wrap(~PartyStratPos)

clm.pred <- predict(clm.mod)
summary(clm.pred)

x <- ys.proposed$didPropose - clm.mod$fitted.values
ys.proposed %<>% cbind(x)
ys.proposed <- ys.proposed %>% rename(clm.residuals = x)
ys.proposed %>% ggplot(aes(PartyStratPos, clm.residuals)) + geom_jitter()
ys.proposed %>% ggplot(aes(PartyStratPos, clm.residuals)) + geom_jitter() + facet_wrap(~year)
ys.proposed %>% filter(actortype == "major" | actortype == "minor") %>% ggplot(aes(PartyStratPos, clm.residuals, color=actor)) + geom_jitter() + facet_wrap(~actortype)
ys.proposed %>% filter(actortype == "major" | actortype == "minor") %>% ggplot(aes(PartyStratPos, clm.residuals)) + geom_jitter() + facet_wrap(~actor)
ys.proposed %>% ggplot(aes(PartyStratPos, clm.residuals)) + geom_jitter() + facet_wrap(~inCoalition)

#maybe parties in color in the graphs?
#minor party in a coalition or not?

plot(ys.proposed$clm.residuals)
plot(ys.proposed$didPropose - clm.pred$fit)

#Generating confusion matrix for CLM model
ys.proposed %<>% mutate(clm50 = ifelse(clm.pred$fit >= 0.5, 1, 0))
ys.proposed %<>% mutate(clm90 = ifelse(clm.pred$fit >= 0.9, 1, 0))

confusionMatrix(as.factor(ys.proposed$clm50), as.factor(ys.proposed$didPropose.num))
confusionMatrix(as.factor(ys.proposed$clm90), as.factor(ys.proposed$didPropose.num))
```


```{r}
#example of ordinal model only, seems to have numerical problems
#strategic position matters. Also independent

model.results <- ys.proposed %>% clmm(as.ordered(didPropose)~as.ordered(StratPos)+(1|actor),., Hess = TRUE)
summary(model.results)
confint(model.results)

plot(model.results$fitted.values, ys.proposed$StratPos)

anova(model.results, clm.mod)

nagelkerke(fit = model.results, null = clm.mod)
#Odds Ratios
exp(coef(model.results)[2])
exp(coef(model.results)[3]) 
exp(coef(model.results)[4])
exp(coef(model.results)[5])
exp(coef(model.results)[6])

y <- ys.proposed$didPropose - model.results$fitted.values
ys.proposed %<>% cbind(y)
ys.proposed <- ys.proposed %>% rename(clmm.residuals = y)
ys.proposed %>% ggplot(aes(StratPos, clmm.residuals)) + geom_jitter()
ys.proposed %>% ggplot(aes(StratPos, clmm.residuals)) + geom_jitter() + facet_wrap(~year)
ys.proposed %>% filter(actortype == "major" | actortype == "minor") %>% ggplot(aes(StratPos, clmm.residuals, color = actor)) + geom_jitter() + facet_wrap(~actortype)
ys.proposed %>% filter(actortype == "major" | actortype == "minor") %>% ggplot(aes(StratPos, clmm.residuals)) + geom_jitter() + facet_wrap(~actor)
ys.proposed %>% ggplot(aes(StratPos, clmm.residuals)) + geom_jitter() + facet_wrap(~actor)
ys.proposed %>% ggplot(aes(StratPos, clmm.residuals)) + geom_jitter() + facet_wrap(~inCoalition)
#Presence of PRD51 and CLV skewed the scale of the general plot towards 0.5. 

#Building confusion matrix for clmm.
ys.proposed %<>% mutate(clmm50 = ifelse(model.results$fitted.values >= 0.5, 1, 0))
ys.proposed %<>% mutate(clmm90 = ifelse(model.results$fitted.values >= 0.9, 1, 0))

#Residual charts for cutoff categorizations.

ys.proposed %<>% mutate(clmm50.resid = didPropose.num-clmm50)
plot(ys.proposed$clmm50)
confusionMatrix(as.factor(ys.proposed$clmm50), as.factor(ys.proposed$didPropose.num))
confusionMatrix(as.factor(ys.proposed$clmm90), as.factor(ys.proposed$didPropose.num))
```


  #H.1.1.1.a 
#Comparing the decision of the ruling party to formulate a counterproposal to other parties in that same state --> Requires  a dummy capturing if the state had single party dominance (single_pty_dom_00_17:True) --> In those states where the condition is met --> the ruling party is more likely to formulate a counterporposal than each opposition party in that same state. 

#Method: Difference of means test: H1: mean of ENTRY for the Ruling Party in a state with single party dominance > mean of ENTRY for each opposition party in that same state; H0: mean of ENTRY for the Ruling Party in a state with single party dominance <= mean of ENTRY for (each) opposition parties in that same state. 
```{r}

require(broom)
require(GGally)
tabfit <- ys.proposed %>% xtabs(~didPropose+didControl+year,data=.)
print(tabfit)
ftable(tabfit)
ys.proposed %>% ggplot(aes(didControl,didPropose))+geom_col()+facet_grid(rows=vars(year))
glmfit <- ys.proposed %>% glm(didPropose~didControl+year,data=.,family=binomial())
summary(glmfit)
augment(glmfit) %>% ggplot(aes(didPropose,.fitted))+geom_jitter()+facet_grid(rows=vars(didControl))
ggcoef(glmfit)
```

  #H.1.1.1.b 
#Comparing the decision of the ruling party to formulate a counterproposal to other parties in states that have expereinced alternation in power. --> Requires a categorical variable capturing if degree of ALTERNATION or simply if single_pty_dom_00_17:False. This hypothesis is evaluating if the ruling party is more likely to formulate a counterporposal in states where there is single party rule, than in states where alternation takes place. 
#Method: Difference of means test: H1: mean of ENTRY for the Ruling Party in states with single party dominance > mean of ENTRY for the Ruling Party in states that have experienced alternation; H0: mean of ENTRY for the Ruling Party in states with single party dominance <= mean of ENTRY for the Ruling Party in states that have experienced alternation. 

#H.1.1.2 Parties that are secondary or terciary forces at the state level, are more likely to participte in redistricting (formulate a counterproposal), than all other opposition parties. 

#H.1.1.3 As alternation in power/ competition increases at the state level, we expect to observe a higher number of counterporposals.
  #H.1.1.3.a number of proposals by single party control.
  
  #H.1.1.3.b number of proposals by degree of alternation

#1.1.1.4 Ruling parties in states with the highest level of alternation in power, are more likely to participte in redistricting (formulate a counterproposal), than all other opposition parties.

//////////////////////////////////////////////////////////////////////////////////////////
H1.2: Strategic Decision (Party deciides how to play the game based on the Ruling Party at the state level) --> Decision of a political party to participate in redistricting based on degree of alternatioin at the state level.
//////////////////////////////////////////////////////////////////////////////////////////

Hypotheses (stage --> First vs Second Round):
 
#H.1.2.1 Parties are more likely to participate in redistricting (formulate a counterproposal) during the first round. --> 

#THEORY:The theory behind this hypothesis is that, ceteris paribus, is that parties are more likely to play the game (propose) during the first stage becasue of the first mover advantage (if your counter proposal is selected in the first round it becomes the departing point for the second round) --> We assume that the margin of change from the first to the second scenario is larger than the margin of change between the second and third scenario (this assumption can be tested with Cox and Katz's difference similarity index). 

#DIAGNOSTICS: a) Breakdown of proposals made in the first vs second stage in 2013 and 2014; b) Breakdown of proposals made in the first vs second stage by party in 2013 and 2014; and c) Breakdown of proposals made in the first vs second stage by state in 2013 and 2014; b) Breakdown of proposals made in the first vs second stage by party and state in 2013 and 2014. 

=====

#H.1.2.2 Parties ruling a state under single party dominance, are more likely to participate in redistricting (formulate a counterproposal) during the first round, than all other opposition parties. 

#THEORY:The theory behind this hypothesis is that, ceteris paribus, dominant parties have more vested interests and will be more likely to engage in the first state than smaller and non-competitive parties. 

#DIAGNOSTICS: a) Breakdown of proposals made in the first vs second stage in 2013 and 2014 controling for strategic position and major vs minor parties;

====

#H.1.2.3 Parties that are secondary or terciary forces at the state level, are more likely to participate in redistricting (formulate a counterproposal) during the first round, than smaller opposition parties.

#THEORY: The theory behind this hypothesis is that, ceteris paribus, parties that are competing for power are more likely to engage in the first state than smaller and non-competitive parties. 

#DIAGNOSTICS: a) Breakdown of proposals made in the first vs second stage in 2013 and 2014 controling for strategic position and major vs minor parties;

===

#1.2.4 As alternation in power/competition increases at the state level, the number of counterporposals in the second stage will be higher compared to states dominated by a single party.

#THEORY:The theory behind this hypothesis is that, ceteris paribus, as competition increases, parties that are competing for power are more likely to engage in the process in the second stage. 

#DIAGNOSTICS: a) Breakdown of proposals made in the first vs second stage in 2013 and 2014 controling for strategic position and major vs minor parties;

Hypotheses (level --> CLV (Local) vs CNV(National):

#H.1.2.5 (centralization/coordination hypothesis) We would expect the CNV to have the upper hand and formulate more proposals in both processes. 

#THEORY:Despite parties can engage both at the local and national level, the redistricting process and the TC session in the main headquarters, which is where the CNV is based. Furthermore, the CNV has a more direct connection with the parties' headquarters in Mexico City (CEN). 

#DIAGNOSTICS: a) Breakdown of proposals mad in the CNV and CLV. 

#H.1.2.6 (Novelty/Learning to play the game) We expect more proposals by the CNV in 2013 than in 2017. 

#THEORY: We expect that given that online interaction was new in 2013, the CNV would be more proactive that year. 
#DIAGNOSTICS: a) Breakdown of proposals mad in the CNV and CLV in 2013 and 2017. 

#H.1.2.7 As alternation in power/competition increases at the state level, parties are more likely to formulate a counterproposal at the local level (CLV)

#THEORY:The theory behind this hypothesis is that  the national headquarters of a party (CNV) are going to be more interested in engaging in those state where the party has a stronghold or is competitive. As competition increases across states, we expect to see smaller parties engaging more at the local level (CLV)

#DIAGNOSTICS: a) Breakdown of proposals made in the CNV vs CLV in 2013 and 2014 controling for strategic position and major vs minor parties;

Hypotheses (Process --> 2013 vs 2017):

#H.1.2.8 We expect to observe more proposals in 2013 than in 2017

#THEORY: Parties are more likely to formulate a counterproposal in because the two levels were more proactive 2013, less precise, and the algorithm was less efficent (allowed greater margin of change). 

#DIAGNOSTICS: a) Breakdown of proposals made in 2013 and 2014

//////////////////////////////////////////////////////////////////////////////////////////
H3: Coalitions
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
H3.1: Coaltions (Stong and Succesful Coaltion)--> Comparing interaction based on the desission to build state level coalitions.  
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis
#3.1.1 Smaller Parties (not PRI, PAN or PRD) are more likely to engage if they are running in a coalition than if they are competing alone.  

#THEORY: Smaller parties have more at stake when they are running with a larger party. 

#DIAGNOSTICS: a) Breakdown of proposals made by smaller parties in coalition and smaller parties racing alone. 

Data Exploration
MINOR PARTIES
```{r}
SP.df <- ys.proposed %>% filter(actortype == "minor") %>% mutate(incoalition = ifelse(extension > 0, 1, 0))
SP.df %>% ggplot(aes(didPropose)) + geom_bar() +facet_grid(rows = vars(incoalition), cols = vars(year))
SP.df %>% ggplot(aes(StratPos)) + geom_bar() +facet_wrap(~incoalition)
SP.df %>% filter(incoalition == 1) %>% ggplot(aes(coalition)) + geom_bar() + theme(axis.text.x = element_text(angle = 90))
```


#3.1.2 Larger Parties (PRI, PAN or PRD) not ruling the state are more likely to engage in the process via a coaliton.  

#THEORY: Larger parties will try to engage the process by making a coalition with smaller parties.  

#DIAGNOSTICS: a) Breakdown of proposals made by non-ruling larger parties in coalition vs non-rulling larger parties racing alone in 2013 and 2017.

MAJOR PARTIES
```{r}
LP.df <- ys.proposed %>% filter(actortype == "major" & singlecontrol == didControl) %>% mutate(incoalition = ifelse(extension > 0, 1, 0))
LP.df %>% ggplot(aes(didPropose)) + geom_bar() +facet_grid(rows = vars(incoalition), cols = vars(year))
LP.df %>% ggplot(aes(StratPos)) + geom_bar() +facet_wrap(~incoalition)
```

Variables
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).
#IV(1): Dummy variable captruing if a party competed under a coalition before redisrticting took place. 

#3.1.3 (Extension and competitiveness) #Smaller parties (not PRI, PAN or PRD) that have a strong and successful coalition with a larger party, are more likely  to formulate a similar counter proposal to its larger coalition mate than smaller parties that competed separately.  

#THEORY: As the coalitions extension and stength increases, parties in the coalition are more likely to engage. 

#DIAGNOSTICS: a) Breakdown of proposals made by parties proposing in coalition based on the level of high extension and competitivness(DUMMY WHERE E>.5 AND C>.5 = 1, Otherwise 0). 

#3.1.3 (Check Matching Proposals): If parties are run in coalition, we expect that they will have matching scores in proposals. 

#THEORY Parties competing together in a coalition should formulate the same plan. 
Matching Process (Practice)
```{r}
#0.1 Coalition hypothesis: If a coalition was formed, Did the plan of minor party(ies) match the score of the major party? --> This is just for verifying our assumption (robustness check). 

coalitions.df %>% xtabs(~coalition, data=.)

coalitions.df %<>% rowwise() %>% mutate(
    CoalitionType = case_when(
      (coalition == "PAN-PNA" | coalition == "PAN-PRD" | coalition == "PAN-PRD-MC" | coalition == "PAN-PRD-PNA" | coalition == "PAN-PRD-PNA-MC" | coalition ==   "PAN-PRD-PT" | coalition == "PAN-PRD-PT-MC" | coalition == "PAN-PT" | coalition == "PAN-PVEM") ~ "PAN", 
       coalition == "PRI-PVEM-PT-PNA" | coalition == "PRI-PVEM-PT" | coalition == "PRI-PVEM-PNA-PT" | coalition == "PRI-PVEM-PNA-ES" | coalition == "PRI-PVEM-PNA" | coalition == "PRI-PVEM" | coalition == "PRI-PT" | coalition == "PRI-PRD" | coalition == "PRI-PNA" | coalition == "PRI-ES" ~ "PRI", 
      coalition == "PRD-MC-PT" | coalition == "PRD-PT" | coalition == "PRD-PT-MC" | coalition == "MORENA-PT-ES" | coalition == "PRD-PNA" | coalition == "PRD-PT-ES" |      coalition == "PRD-PT-PNA" ~ "Left"
    )
  )

## Joining coalition dataset to the full proposal dataset
 propfull.df %<>%
  left_join(coalitions.df, by=c("edon", "year", "actor"))

## Filters out 1st and 2nd stage proposals and parties that PROPOSED.
##Parties in the coalitions may not propose even when the coalition proposes -- still want to capture minor parties who do not propose on their own
#Two majors w/ diff scores, two minors w different scores
 
#matching.df.coal %<>% filter(stage == 2 | stage == 4) %>% 
  #filter(PROPOSED == TRUE) %>% group_by(edon, year) %>% 
  #mutate(inCoalition=ifelse(CoalitionStratPos > 0, 1, 0),
         #minSCORE = ifelse(SCORE == min(SCORE), 1, 0),
        # minSCOREnum = min(SCORE)) %>%
  #as.tibble() #may need to also filter out parties not in coalitions for simplicity, will check the dataframe


## Subset out scores winning scores for each stage (1, 3, and 5) as well as pull out each partisan score (stage 2 and 4)
first.scenario.df <- propfull.df %>% #Algorithm score 
  filter(stage == 1) %>% 
  select(edon, year, SCORE) %>% 
  rename(FS_SCORE = SCORE)

partisan_FS_SCORE.df <- propfull.df %>% #First round party scores
  filter(stage == 2 & PROPOSED == TRUE) %>% 
  select(., -stage) %>%
  rename(partisan_FS_SCORE = SCORE)

second.scenario.df <- propfull.df %>% #Who won the "first round"-> score that was selected to be the benchmark against which the second round scores are compared
  filter(stage == 3) %>% 
  select(edon, year, SCORE) %>% 
  rename(SS_SCORE = SCORE)

partisan_SS_SCORE.df <- propfull.df %>% #second round party scores
  filter(stage == 4 & PROPOSED == TRUE) %>% 
  select(., -stage) %>% 
  rename(partisan_SS_SCORE = SCORE)

winningscores.df <- propfull.df %>% #final score -- the "Winner"
  filter(stage == 5) %>% 
  select(edon, year, SCORE) %>% 
  rename(Win_SCORE = SCORE)

#Join the Stage 1, 3, 5 Scores together since they are independent of party
temp1 <- Reduce(function(x, y) merge(x, y, by = c("edon", "year")),
                list(first.scenario.df, second.scenario.df, winningscores.df))
temp2 <- Reduce(function(x, y) merge(x, y, by = c("edon", "year", "actor", "govlevel"), all=TRUE, no.dups=FALSE),
                list(partisan_FS_SCORE.df, partisan_SS_SCORE.df))

WM_coal.df <- win_match.coal.df.tmp5
##Create dummy matching minimum scores to the winning score
WM_coal.df %<>% group_by(edon, year, govlevel) %>% 
  mutate(ACTOR_WIN = if_else(SCORE == Win_SCORE, 1, 0),
         ALG_WIN = if_else(FS_SCORE == Win_SCORE, 1, 0),
         MIN_WIN = if_else(minSCOREnum == Win_SCORE, 1, 0))

#test
test <- WM_coal.df %>%
  filter(edon == 1)

```

```{r}
#2.1 Code to create a proportion of success rate based on the proportion of plans adopted (Proportion winning   plans = Partisan plans that were adopted / Total amout of proposals formulated by each party)-->               This requires for the FIRST STAGE: 1) compareing the FIRST SCENARIO with PARTISAN PLANS, possible              outcomes in terms of the cost function: 


##########################################################################################
partisan_FS_SCORE.df <- matching.df.coal %>% filter(stage == 2) %>% select(edon, year, SCORE, actor) %>% rename(partisan_FS_SCORE = SCORE)
partisan_SS_SCORE.df <- matching.df.coal %>% filter(stage == 4) %>% select(edon, year, SCORE, actor) %>% rename(partisan_SS_SCORE = SCORE)

win_match.coal.df %<>% inner_join(partisan_FS_SCORE.df, by=c("edon", "year", "actor"))
win_match.coal.df %<>% inner_join(partisan_SS_SCORE.df, by=c("edon", "year", "actor"))

#a) First scenario > partisan plan, verify if partisan plan was accepted   (PARTISAN PLAN should match the score of the SECOND SCENARIO) --> Party Success!;
win_match.coal.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.A = ifelse(FS_SCORE > partisan_FS_SCORE & partisan_FS_SCORE == SS_SCORE, 1, 0))

#a.1 Second Scenario Partisan Plan == Win Score
win_match.coal.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.A.1 = ifelse(SS_SCORE > partisan_SS_SCORE & partisan_SS_SCORE == Win_SCORE, 1, 0))

#b) First scenario < cost than   partisan plans, verify if Fisrt scenario became the second scenario (FIRST SCENARIO should match the score of    the SECOND SCENARIO) --> EMB/Algorithm success!; 
win_match.coal.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.B = ifelse(FS_SCORE < partisan_FS_SCORE & FS_SCORE == SS_SCORE, 1, 0))

#c) First scenario > partisan plan, the outcome registered for the second scenario is different from partisan proposal --> ==Inconsistency type 1==, subsequent options: 
win_match.coal.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Inconsistency1 = ifelse(FS_SCORE > partisan_FS_SCORE & partisan_FS_SCORE != SS_SCORE, 1, 0))
#d) First scenario < cost than partisan plans, the outcome registered for the second scenario is different from the First scenario --> ==Inconsistency type 2==, subsequent options:
win_match.coal.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Inconsistency2 = ifelse(FS_SCORE < partisan_FS_SCORE & FS_SCORE != SS_SCORE, 1, 0))

win_match.coal.df %>% filter((actortype == "major" | actortype == "minor") & stage.x == 2) %>%
  group_by(year, CoalitionType) %>% summarise(WIN = sum(Scen.2.1.A), denominator = sum(n()), percent = (WIN/denominator)*100) %>%
  gt() %>%
    cols_label("CoalitionType" = "Party", "WIN" = "Accepted Proposals", "denominator" = "Total Proposals", "percent" = "% Accepted") %>%
    tab_header(title = "First Stage Redistricting Proposals")

#Generating table for Second Stage Party Wins
win_match.coal.df %>% filter((actortype == "major" | actortype == "minor") & stage.x == 4) %>%
  group_by(year, CoalitionType) %>% summarise(WIN = sum(Scen.2.1.A.1), denominator = n(), percent = (WIN/denominator)*100) %>%
  gt() %>%
    cols_label("CoalitionType" = "Party", "WIN" = "Accepted Proposals", "denominator" = "Total Proposals", "percent" = "% Accepted") %>%
    tab_header(title = "Second Stage Redistricting Proposals")

win_match.coal.df <- unique(win_match.coal.df)

major.score <- matching.df.coal %>% filter(actortype == "major" & stage == 2) %>% select(edon, year, govlevel, SCORE, actor) %>% rename(Maj_Party_Score = SCORE)
matching.df.coal <- left_join(matching.df.coal, major.score, by=c("edon", "year", "govlevel"))
matching.df.coal <- matching.df.coal %>%
  group_by(edon, year, govlevel, coalition) %>%
  mutate(maj_min_match = if_else(SCORE == Maj_Party_Score, 1, 0))

matching.df.coal <- unique(matching.df.coal)

matching.df.coal %>% filter(actortype == "minor" & stage.x == 2) %>%
  group_by(edon, govlevel, year, coalition, maj_min_match) %>%
  filter(year == 2013) %>%
  summarise(., n()) %>%
  gt()

matching.df.coal %>% filter(actortype == "minor" & stage.x == 2) %>%
  group_by(edon, govlevel,  year, coalition, maj_min_match) %>%
  filter(year == 2017) %>%
  summarise(., n()) %>%
  gt()
####STAGES

#Stage 2 = Stage 1
#Stage 4 = Stage 2
#the other stages capture other score related data

#0.2 The EMB/Algorithm should be treated as an "actor" in the game (and in the analysis of #1 and #2 below), where the scroe associated to the FIRST SCENARIO should be treated as its own plan. If this plans prevails across the two stages --> EMB/Algorithm wins

#0.3 Level of Engagement.This measure captures the degree of intensity of partisan engagment in the process by year. In general, we think of engagment as an ordinal variable, where the minimum level of partisan engagment in a given year is 0 (a party does not formulate a counterproposal in a state at any stage or level) and the maximum degree of engagment is 4 (a party fomulates a counterproposal in two stages and at the two levels at a given state/year). 

  #0.3.1 Count Measure of engagment --> Code that aggregates the level of engagment by parties for every           state/year. Possible categories: i. Parties at the minimum do not engage at all in the process for a given       state/year (0), ii. Parties formulated only one proposal (regardles of the stage and level), iii. Parties        formulates two proposals (regardles of the stage and level), iv.Parties formulated three proposals (regardles    of the stage and level), and v. Parties formulated four proposals (regardles of the stage and level). 

  #0.3.2 Descriptive level of engagment by party  --> Code for generating tables and visualizations that           aggregate proposals by party at the year, stage, and level. 

  #0.3.3 Descriptive level of engagment by party and state  --> Code for generating tables and visualizations      that aggregate proposals by party at the year, stage, and level.
```

```{r}
#1.Efficiency hypothesis (Part 1: lowest score): RQ: Which party/parties were more effective in formulating plans with the lowest cost? --> We theorize that 1) major parties will be more efficient than smaller ones, 2) that PAN, at least in 2013 and at the national level, was the most efficent party because of its level of professionalization, and 3) that because of algorithm efficeny and learning experience, 3.1) PAN became less efficient between 2013 and 2017, and 3.2) other parties performed better between years and levels. 

  #1.1 Code to identify which party formulated the plan with the lowest cost in every stage, state, level, and     year.
matching.df.1 <- propfull.df %>% mutate(minSCORE = 0)
matching.df.1 %<>% filter(stage == 2 | stage == 4) %>% filter(PROPOSED == TRUE) %>% group_by(edon, stage, year, govlevel) %>% mutate(minSCORE = ifelse(SCORE == min(SCORE), 1, 0)) %>% mutate(minSCOREnum = min(SCORE))

##BY ACTOR
matching.df.1 %>% ggplot(aes(minSCORE)) + geom_bar() +facet_wrap(~actor)

matching.df.1 %>% ggplot(aes(year, minSCOREnum)) + geom_jitter() +facet_wrap(~actor)

#all scores, color code the min scores
matching.df.1 %>% ggplot(aes(stage, SCORE, color = minSCORE)) + geom_jitter() +facet_wrap(~actor)

#color code by year
matching.df.1 %>% ggplot(aes(govlevel, minSCOREnum, color = year)) + geom_jitter() +facet_wrap(~actor)


##BY STATE
matching.df.1 %>% ggplot(aes(year, minSCOREnum)) + geom_jitter() +facet_wrap(~Entidad)
matching.df.1 %>% ggplot(aes(stage, minSCOREnum)) + geom_jitter() +facet_wrap(~Entidad)

#Color year
matching.df.1 %>% ggplot(aes(govlevel, minSCOREnum)) + geom_jitter() +facet_wrap(~Entidad)

  #1.2  Code to create a proportion of lowest score plans formulated by each party by year, level, stage, and      state (Proportion lowest scores = Plans with lowest score formulated by each party / Total amout of proposals   formulated by each party) 

      #1.2.1--> Descriptive results by party (lowest score): Create code: Descriptive graphs and tables. 

      #1.2.2 --> Evaluation Questions (Bias/Transparency): a) Was there a party that sistematically proposed           lower cost scenarios?
```

```{r}
#2. Efficiency hypothesis (Part 2: winning proposals) RQ: Which party/parties were more effective in formulating plans that were accepted by the TC/EMB? --> Again (same as #1, but evaluated with a different measure), we theorize that [[1. DID THE PARTY "WIN" & 2. DID THEY WIN WITH MINSCORE?]]

#1) major parties will be more efficient than smaller ones,
#2) that PAN, at least in 2013 and at the national level, was the most efficent party because of its level of professionalization, 
#3) that because of algorithm efficeny and learning experience, 
    #3.1) PAN became less efficient between 2013 and 2017, 
    #3.2) other parties performed better between years and levels.

## Subset out winning scores
first.scenario.df <- propfull.df %>% filter(stage == 1) %>% select(edon, year, SCORE) %>% rename(FS_SCORE = SCORE)
second.scenario.df <- propfull.df %>% filter(stage == 3) %>% select(edon, year, SCORE) %>% rename(SS_SCORE = SCORE)
winningscores.df <- propfull.df %>% filter(stage == 5) %>% select(edon, year, SCORE) %>% rename(Win_SCORE = SCORE)

##Rejoin winning scores to the matching dataframe
win_match.df <- matching.df.1 %>% inner_join(first.scenario.df, by=c("edon", "year"))
win_match.df %<>% inner_join(second.scenario.df, by=c("edon", "year"))
win_match.df %<>% inner_join(winningscores.df, by=c("edon", "year"))

##Create dummy matching minimum scores to the winning score
win_match.df %<>% group_by(edon, stage, year, govlevel) %>% mutate(WIN = ifelse(SCORE == Win_SCORE, 1, 0))

#2.1 Code to create a proportion of success rate based on the proportion of plans adopted (Proportion winning   plans = Partisan plans that were adopted / Total amout of proposals formulated by each party)-->               This requires for the FIRST STAGE: 1) compareing the FIRST SCENARIO with PARTISAN PLANS, possible              outcomes in terms of the cost function: 


##########################################################################################
partisan_FS_SCORE.df <- matching.df.1 %>% filter(stage == 2) %>% select(edon, year, SCORE, actor) %>% rename(partisan_FS_SCORE = SCORE)
partisan_SS_SCORE.df <- matching.df.1 %>% filter(stage == 4) %>% select(edon, year, SCORE, actor) %>% rename(partisan_SS_SCORE = SCORE)

win_match.df %<>% inner_join(partisan_FS_SCORE.df, by=c("edon", "year", "actor"))
win_match.df %<>% inner_join(partisan_SS_SCORE.df, by=c("edon", "year", "actor"))
#do the subsetting thing from line 450 for parties -- state year party score -- filter by stage again -- i can compare to FS_SCORE and SS_SCORE and to the indv party scores (PARTISAN_FS_SCORE and PARTISAN_SS_SCORE)
#######SCORE Stage == 2 equivalent to SCORE Stage ==4
#group by party and all the other things = create neww var that generates the score for each stage
#compare stage 2 and 4 generate neww var that is a binary for matching
#now e can also do greater than or less than
##############################################################################################
##FIRST SCEN == algorithm
##SECOND SCEN == winner from first round

##Notes:
#transpa


#a) First scenario > partisan plan, verify if partisan plan was accepted   (PARTISAN PLAN should match the score of the SECOND SCENARIO) --> Party Success!;
win_match.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.A = ifelse(FS_SCORE > partisan_FS_SCORE & partisan_FS_SCORE == SS_SCORE, 1, 0))
#Graphs
win_match.df %>% ggplot(aes(Scen.2.1.A)) + geom_bar() + facet_wrap(~actor)
win_match.df %>% ggplot(aes(as.factor(year), SCORE, color = Scen.2.1.A)) + geom_jitter() + facet_wrap(~actor)


#a.1 Second Scenario Partisan Plan == Win Score
win_match.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.A.1 = ifelse(SS_SCORE > partisan_SS_SCORE & partisan_SS_SCORE == Win_SCORE, 1, 0))



#b) First scenario < cost than   partisan plans, verify if Fisrt scenario became the second scenario (FIRST SCENARIO should match the score of    the SECOND SCENARIO) --> EMB/Algorithm success!; 
win_match.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Scen.2.1.B = ifelse(FS_SCORE < partisan_FS_SCORE & FS_SCORE == SS_SCORE, 1, 0))
#graphs
win_match.df %>% ggplot(aes(Scen.2.1.B)) + geom_bar() + facet_wrap(~actor)

#c) First scenario > partisan plan, the outcome registered for the second scenario is different from partisan proposal --> ==Inconsistency type 1==, subsequent options: 
win_match.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Inconsistency1 = ifelse(FS_SCORE > partisan_FS_SCORE & partisan_FS_SCORE != SS_SCORE, 1, 0))
    #i) observed score in second scenario = First Scenario
    #ii) observed score in second scenario is higher than the partisan plan with the lowest score, but lower than the first scenario 
    #iii) observed score in second scenario is higher than the partisan plan with the lowest score, and higher than the first scenario
    #iv)observed score in second scenario is lower than the partisan plan with the lowest score, and higher than the first scenario
    #v) observed score in second scenario is lower than the partisan plan with the lowest score,   and lower than the first scenario
#d) First scenario < cost than partisan plans, the outcome registered for the second scenario is different from the First scenario --> ==Inconsistency type 2==, subsequent options:
win_match.df %<>% group_by(edon, stage, year, govlevel, actor) %>% mutate(Inconsistency2 = ifelse(FS_SCORE < partisan_FS_SCORE & FS_SCORE != SS_SCORE, 1, 0))
    #i) observed score in second scenario is lower than the First Scenario
    #ii) observed score in second scenario is higher the first scenario, but lower than the lowerst partisan counterproposal
    #iii) observed score in second scenario is higher the first scenario and equal to the lowest partisan score
    #iv) observed score in second   scenario is higher the first scenario and higher to the lowest partisan score.

      #2.1.1 --> Descriptive results by party (winning propsal): Create code: Descriptive graphs and tables. 

      #2.1.2--> Evaluation Questions (Bias/Transparency):a) Were some parties a parties more effective than others? Did inconsistencies affected sistematically a specific party?

#3 Algorithm Efficency

#3.1 When comparing efficiency (lowest and winning proposals), is there evdidence showing that the propotion of lower scores in 2013 > than in 2017? 

#3.2 Were EMB/Algorithm proposals more effective in 2017 than in 2013?


############
#Generating Table for Overall wins by party by year
win_match.df %>% filter((actortype == "major" | actortype == "minor")) %>%
  group_by(year, actor) %>% summarise(WIN = sum(WIN), PROPOSED = sum(PROPOSED), percent = (WIN/PROPOSED)*100) %>%
  gt()

#Generating table for First Stage Party Wins (Scenario 2.1.A)
win_match.df %>% filter((actortype == "major" | actortype == "minor") & stage.x == 2) %>%
  group_by(year, actor) %>% summarise(WIN = sum(Scen.2.1.A), denominator = sum(n()), percent = (WIN/denominator)*100) %>%
  gt() %>%
    cols_label("actor" = "Party", "WIN" = "Accepted Proposals", "denominator" = "Total Proposals", "percent" = "% Accepted") %>%
    tab_header(title = "First Stage Redistricting Proposals")

#Generating table for Second Stage Party Wins
win_match.df %>% filter((actortype == "major" | actortype == "minor") & stage.x == 4) %>%
  group_by(year, actor) %>% summarise(WIN = sum(Scen.2.1.A.1), denominator = n(), percent = (WIN/denominator)*100) %>%
  gt() %>%
    cols_label("actor" = "Party", "WIN" = "Accepted Proposals", "denominator" = "Total Proposals", "percent" = "% Accepted") %>%
    tab_header(title = "Second Stage Redistricting Proposals")

```



Vote Share Data loading
```{r}
#Load in package to read in Github urls directed towards necessary data
install.packages("readr")
require(readr)

#Vhat Data
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vhat-2015.csv"
Vhat.2015 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vhat-2012.csv"
Vhat.2012 <- read.csv(url(url.file))

#Vraw Data
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2018.csv"
Vraw.2018 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2015.csv"
Vraw.2015 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2012.csv"
Vraw.2012 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2009.csv"
Vraw.2009 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2006.csv"
Vraw.2006 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2003.csv"
Vraw.2003 <- read.csv(url(url.file))
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2000.csv"
Vraw.2000 <- read.csv(url(url.file))


#There will end up being a mismatch -- the party names are different than the ones in propfull & ys.proposed. 1) Alter the names, created aggregations HERE to compensate 2) go through integrateMxdistritos and planScoreFunctions to change how the actors are recorded at the source 3) could do major/minor party break down 4) PAN, PRI, PRD, Left grouping like Eric does in his data/analysis

#How many years are we brining in? Eric has seccion level data going back in three year intervals to the 90s + 2018 electoral returns (Can test the change after redistricting by comparing 2018 to 2015 (for 2017), and 2015 to 2012 (for 2013))
# five last elections
```

```{r}

Vraw.2015.x <- Vraw.2015
Merge.2015 <- left_join(x = Vraw.2015.x, y = Vhat.2015, by = c("edon", "seccion"))
Merge.2015  %<>% pivot_longer(., cols = c("pan.x", "pri.x", "prd", "pvem", "pt", "mc", "pna", "morena", "ph", "pes", "prdc", "pric"),
                            names_to = "actor",
                            values_to = "votes.2015")

Merge.2015 %<>% na.omit() %>%
  group_by(edon, disn, actor) %>%
  summarise(., votes.2015 = sum(votes.2015),
            lisnom.2015 = sum(lisnom),
            efec.2015 = sum(efec.x),
            vhat.pan = mean(vhat.pan),
            vhat.pri = mean(vhat.pri),
            vhat.left = mean(vhat.left)) %>%
    mutate(VoteShare.2015 = (votes.2015/efec.2015)*100)

#Defines the "rentability" of each each district by party vote share in said district.
#A measure of a party's electoral prospects in a district (Extremely Rentable == GOOD electoral prospects)
Merge.2015 %<>% rowwise() %>% mutate(
    Rentability = case_when(
      VoteShare.2015 > 90    ~ 1, # Extremely Rentable
      VoteShare.2015 > 50    ~ 2, # Rentable
      VoteShare.2015 > 30    ~ 3, # Moderately Rentable
      VoteShare.2015 <= 30   ~ 4, # Weakly Rentable
    )
  )
Merge.2015 %>% 
  group_by(., actor, Rentability) %>% 
  summarise(., n(), mean(VoteShare.2015), mean(vhat.pan)*100, mean(vhat.pri)*100, mean(vhat.left)*100) %>%
  gt() %>%
  cols_label("n()" = "# of District Scores")

Merge.2015 %<>%
  pivot_longer(., cols = c("vhat.pan", "vhat.pri", "vhat.left"),
               names_to = "vhatgroup",
               values_to = "vhat_VS")
Merge.2015 %<>%
  group_by(edon, disn) %>%
  mutate(WIN = if_else(VoteShare.2015 == max(VoteShare.2015), 1, 0)) %>%
  mutate(WIN.vhat = if_else(vhat_VS == max(vhat_VS), 1, 0))

Merge.2015 %>%
  group_by(., actor, WIN) %>%
  summarise(., n()/900*100) %>%
  gt()

Merge.2015 %>%
  group_by(., vhatgroup, WIN.vhat) %>%
  summarise(., n()/3600*100) %>%
  gt()


Vraw.2015 %<>% pivot_longer(., cols = c("pan", "pri", "prd", "pvem", "pt", "mc", "pna", "morena", "ph", "pes", "prdc", "pric"),
                            names_to = "actor",
                            values_to = "votes.2015")
Vraw.2012 %<>% pivot_longer(., cols = c("pan", "pri", "prd", "pvem", "pt", "mc", "pna", "prdc", "pric"),
                            names_to = "actor",
                            values_to = "votes.2012")
merge_1 <- left_join(x = Vraw.2015, y = Vraw.2012, by = c("edon", "disn", "seccion", "actor"))
merge_1 %<>% mutate(avg_vote = ((votes.2015 + votes.2012)/2)) %>%
  mutate(avg_efec = ((efec.x + efec.y)/2)) %>%
  mutate(avg_VS = (avg_vote/avg_efec)*100)

merge_1 %<>% group_by(edon, disn, actor) %>%
  summarise(.,
            avg_VS = mean(avg_VS))

merge_1 %<>% na.omit() %>%
  mutate(WIN = if_else(avg_VS == max(avg_VS), 1, 0))

merge_1 %>%
  group_by(., actor, WIN) %>%
  summarise(., n()/240*100) %>%
  gt()


#++++++++++++++++++++++++++++++++++++
Vraw.2006 <- Vraw.2006 %>%
  rename(., prd = prdc)

Vraw.2009 %<>% pivot_longer(., cols = c("pan", "pri", "prd", "pvem", "pt", "conve", "pna", "psd", "pric", "ptc"),
                            names_to = "actor",
                            values_to = "votes.2009")
Vraw.2006 %<>% pivot_longer(., cols = c("pan", "pric", "prd", "pna", "asdc"),
                            names_to = "actor",
                            values_to = "votes.2006")
merge_2 <- left_join(x = Vraw.2012, y = Vraw.2009, by = c("edon", "disn", "seccion", "actor"))
merge_2 <- left_join(x = merge_2, y = Vraw.2006, by = c("edon", "disn", "seccion", "actor"))
merge_2 %<>% mutate(avg_vote = ((votes.2012 + votes.2009 + votes.2006)/3)) %>%
  mutate(avg_efec = ((efec.x + efec.y + efec)/3)) %>%
  mutate(avg_VS = (avg_vote/avg_efec)*100)

merge_2 %<>% group_by(edon, disn, actor) %>%
  summarise(.,
            avg_VS = mean(avg_VS))
merge_2 %<>% na.omit() %>%
  mutate(WIN = if_else(avg_VS == max(avg_VS), 1, 0))

merge_2 %>%
  group_by(., actor, WIN) %>%
  summarise(., n()/230*100) %>%
  gt()
#+++++++++++++++++++++++++++++++++++++++++
merge_3 <- left_join(x = Vraw.2012, y = Vraw.2009, by = c("edon", "disn", "seccion", "actor"))
merge_3 %<>% mutate(avg_vote = ((votes.2012 + votes.2009)/2)) %>%
  mutate(avg_efec = ((efec.x + efec.y)/2)) %>%
  mutate(avg_VS = (avg_vote/avg_efec)*100)

merge_3 %<>% group_by(edon, disn, actor) %>%
  summarise(.,
            avg_VS = mean(avg_VS))
merge_3 %<>% na.omit() %>%
  mutate(WIN = if_else(avg_VS == max(avg_VS), 1, 0))

merge_3 %>%
  group_by(., actor, WIN) %>%
  summarise(., n()/244*100) %>%
  gt()

#=================================
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2012.csv"
Vraw.2012 <- read.csv(url(url.file))
Merge.2012 <- left_join(x = Vraw.2012, y = Vhat.2012, by = c("edon", "seccion"))
Merge.2012  %<>% pivot_longer(., cols = c("pan.x", "pri.x", "prd", "pvem", "pt", "mc", "pna", "prdc", "pric"),
                            names_to = "actor",
                            values_to = "votes.2012")

Merge.2012 %<>% na.omit() %>%
  group_by(edon, disn, actor) %>%
  summarise(., votes.2012 = sum(votes.2012),
            lisnom.2012 = sum(lisnom),
            efec.2012 = sum(efec.x),
            vhat.pan = mean(vhat.pan),
            vhat.pri = mean(vhat.pri),
            vhat.left = mean(vhat.left)) %>%
    mutate(VoteShare.2012 = (votes.2012/efec.2012)*100)

#Defines the "rentability" of each each district by party vote share in said district.
#A measure of a party's electoral prospects in a district (Extremely Rentable == GOOD electoral prospects)
Merge.2012 %<>% rowwise() %>% mutate(
    Rentability = case_when(
      VoteShare.2012 > 90    ~ 1, # Extremely Rentable
      VoteShare.2012 > 50    ~ 2, # Rentable
      VoteShare.2012 > 30    ~ 3, # Moderately Rentable
      VoteShare.2012 <= 30   ~ 4, # Weakly Rentable
    )
  )
Merge.2012 %>% 
  group_by(., actor, Rentability) %>% 
  summarise(., n(), mean(VoteShare.2012), mean(vhat.pan)*100, mean(vhat.pri)*100, mean(vhat.left)*100) %>%
  gt() %>%
  cols_label("n()" = "# of District Scores")

Merge.2012 %<>%
  pivot_longer(., cols = c("vhat.pan", "vhat.pri", "vhat.left"),
               names_to = "vhatgroup",
               values_to = "vhat_VS")
Merge.2012 %<>%
  group_by(edon, disn) %>%
  mutate(WIN = if_else(VoteShare.2012 == max(VoteShare.2012), 1, 0)) %>%
  mutate(WIN.vhat = if_else(vhat_VS == max(vhat_VS), 1, 0))

Merge.2012 %>%
  group_by(., actor, WIN) %>%
  summarise(., n()/900*100) %>%
  gt()

Merge.2012 %>%
  group_by(., vhatgroup, WIN.vhat) %>%
  summarise(., n()/3600*100) %>%
  gt()
```

RULE 8 ANALYSIS
```{r}
#Create a column for actor (to more easily merge with other datasets), votes are values associated w/ each actor category
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2018.csv"
Vraw.2018 <- read.csv(url(url.file))

Vraw.2018 <- Vraw.2018 %>%
  mutate(pan = pan + panc) %>%
  mutate(pri = pri + pric) %>%
  mutate(morena = morena + morenac) %>%
  select(., -panc, -pric, -morenac)

Vraw.2018 %<>% pivot_longer(., cols = c("pan", "pri", "prd", "pvem", "pt", "mc", "pna", "morena", "pes"),
                            names_to = "actor",
                            values_to = "votes_2018")
Vraw.2018 <- Vraw.2018 %>%
  mutate(actor = toupper(actor))

#Aggregate numbers by district and
#Generate values for vote share by actor
Vraw.2018 %<>% na.omit() %>%
  group_by(edon, disn, actor) %>%
  summarise(., votes_2018 = sum(votes_2018),
            lisnom_2018 = sum(lisnom),
            efec_2018 = sum(efec),
            dpanc_2018 = sum(dpanc),
            dpric_2018 = sum(dpric),
            dmorenac_2018 = sum(dmorenac)) %>%
  mutate(VoteShare_2018 = (votes_2018/efec_2018)*100,
         dpanc = if_else(dpanc_2018 > 0, 1, 0),
         dpric = if_else(dpric_2018 > 0, 1, 0),
         dmorena = if_else(dmorenac_2018 > 0, 1, 0)) %>%
  select(., -dpanc_2018, - dpric_2018, -dmorenac_2018)

Vraw.2018 %<>% as.tibble() %>%
  group_by(edon, disn) %>%
  mutate(Max_VS = max(VoteShare_2018),
         Seat_Win = if_else(VoteShare_2018 == Max_VS, 1, 0)) %>%
  select(., -Max_VS)

Vraw.2018 %<>% na.omit() %>%
  group_by(edon, actor) %>%
  summarise(., votes_2018 = sum(votes_2018),
            lisnom_2018 = sum(lisnom_2018),
            efec_2018 = sum(efec_2018),
            dpanc_2018 = sum(dpanc),
            dpric_2018 = sum(dpric),
            dmorenac_2018 = sum(dmorena),
            Seat_Win_2018 = sum(Seat_Win)) %>%
  mutate(VoteShare_2018 = (votes_2018/efec_2018)*100,
         dpanc = if_else(dpanc_2018 > 0, 1, 0),
         dpric = if_else(dpric_2018 > 0, 1, 0),
         dmorena = if_else(dmorenac_2018 > 0, 1, 0))  %>%
  select(., -dpanc_2018, - dpric_2018, -dmorenac_2018)

#Defines the "rentability" of each each district by party vote share in said district.
#A measure of a party's electoral prospects in a district (Extremely Rentable == GOOD electoral prospects)
Vraw.2018 %<>% rowwise() %>% mutate(
    Rentability_2018 = case_when(
      VoteShare_2018 > 90    ~ 1, # Extremely Rentable
      VoteShare_2018 > 50    ~ 2, # Rentable
      VoteShare_2018 > 30    ~ 3, # Moderately Rentable
      VoteShare_2018 <= 30   ~ 4, # Weakly Rentable
    )
  )

#Create a column for actor (to more easily merge with other datasets), votes are values associated w/ each actor category
url.file <- "https://raw.githubusercontent.com/emagar/mxDistritos/master/data/dipfed-seccion-vraw-2015.csv"
Vraw.2015 <- read.csv(url(url.file))

Vraw.2015 <- Vraw.2015 %>%
  mutate(prd = prd + prdc) %>%
  mutate(pri = pri + pric) %>%
  select(., -ph, -prdc, -pric)

Vraw.2015 %<>% pivot_longer(., cols = c("pan", "pri", "prd", "pvem", "pt", "mc", "pna", "morena", "pes"),
                            names_to = "actor",
                            values_to = "votes_2015")
Vraw.2015 <- Vraw.2015 %>%
  mutate(actor = toupper(actor))

Vraw.2015 %<>% na.omit() %>%
  group_by(edon, disn, actor) %>%
  summarise(., votes_2015 = sum(votes_2015),
            lisnom_2015 = sum(lisnom),
            efec_2015 = sum(efec),
            dprdc_2015 = sum(dprdc),
            dpric_2015 = sum(dpric)) %>%
  mutate(VoteShare_2015 = (votes_2015/efec_2015)*100,
         dprdc = if_else(dprdc_2015 > 0, 1, 0),
         dpric = if_else(dpric_2015 > 0, 1, 0)) %>%
  select(., -dprdc_2015, - dpric_2015)

Vraw.2015 %<>% as.tibble() %>%
  group_by(edon, disn) %>%
  mutate(Max_VS = max(VoteShare_2015),
         Seat_Win = if_else(VoteShare_2015 == Max_VS, 1, 0)) %>%
  select(., -Max_VS)

Vraw.2015 %<>% na.omit() %>%
  group_by(edon, actor) %>%
  summarise(., votes_2015 = sum(votes_2015),
            lisnom_2015 = sum(lisnom_2015),
            efec_2015 = sum(efec_2015),
            dprdc_2015 = sum(dprdc),
            dpric_2015 = sum(dpric),
             Seat_Win_2015 = sum(Seat_Win)) %>%
  mutate(VoteShare_2015 = (votes_2015/efec_2015)*100,
         dprdc = if_else(dprdc_2015 > 0, 1, 0),
         dpric = if_else(dpric_2015 > 0, 1, 0)) %>%
  select(., -dprdc_2015, - dpric_2015)

#Defines the "rentability" of each each district by party vote share in said district.
#A measure of a party's electoral prospects in a district (Extremely Rentable == GOOD electoral prospects)
Vraw.2015 %<>% rowwise() %>% mutate(
    Rentability_2015 = case_when(
      VoteShare_2015 > 90    ~ 1, # Extremely Rentable
      VoteShare_2015 > 50    ~ 2, # Rentable
      VoteShare_2015 > 30    ~ 3, # Moderately Rentable
      VoteShare_2015 <= 30   ~ 4, # Weakly Rentable
    )
  )

Vraw_df <- left_join(Vraw.2015, Vraw.2018, by = c("edon", "actor"))

Vraw_df %>%
  group_by(actor) %>%
  summarise(., sum(Seat_Win_2015), mean(VoteShare_2015), sum(Seat_Win_2018), mean(VoteShare_2018)) %>%
  gt()
```

#DIAGNOSTICS: a) Breakdown of proposals matching scores when parties ran in coalition (create a dummy)


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
STOP READING HERE (Below: Departing ideas for conversation 01/14/20)
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////
H1: Ruling Party (Single Party Dominance/Alternation)
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
H1.1: Single Party Dominance (dominant party) --> Comparing dominant parties vs opposition parties in states ruled by a single party
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis:
# If a state is dominated by a single party prior the redistricting process, the ruling party in that state is more likely to formulate a counterproposal than any other party. 

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a single party ruled that state before redisrticting took place (single_pty_dom_00_17:True or False, by State). 

#IV(2): Categorical variable captruing the degree of alternation in power (six categories from a non-competitive state to a party that has multiparty comptetion and alternation has taken place >3+ times in the 00-17 period): 1) single_pty_dom_00_17:True or False, by State; 2) alt_power1_00_17; 3) alt_power2_00_17; 4) alt_power2_00_17 x multi_comp_00_17; 5) alt_power3_00_17; 6) alt_power3_00_17 x multi_comp_00_17. 

Method:
#To test H1.1: chi.sq test.

#Comparing parties:If the hypothesis is true, we would expect that the dominating party in states ruled by a single party, is more likely to formulate a counterporposal than opposition parties (this hypothesis can be tested by stage and/or combining both stages 1 and 2).

//////////////////////////////////////////////////////////////////////////////////////////
H1.2: Alternation in Power (opposition party(ies)) --> Comparing opposition parties in states with alternation vs opposition parties in states ruled by a single party
//////////////////////////////////////////////////////////////////////////////////////////
Hypotheses:
# If a state has gone through alternation in power, the main oppoition party (secondary force) is as likely to formulate a counterporposal as the ruling party.

# If a state has gone through alternation in power, oppoition parties are as likely to formulate a counterporposal as the ruling party.

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a single party ruled that state before redisrticting took place (single_pty_dom_00_17:True or False, by State). 

#IV(2): Categorical variable captruing the degree of alternation in power (six categories from a non-competitive state to a party that has multiparty comptetion and alternation has taken place >3+ times in the 00-17 period): 1) single_pty_dom_00_17:True or False, by State; 2) alt_power1_00_17; 3) alt_power2_00_17; 4) alt_power2_00_17 x multi_comp_00_17; 5) alt_power3_00_17; 6) alt_power3_00_17 x multi_comp_00_17. 

Method: 
#To test H1.1: chi.sq test.

#Comparing parties: In states that have experienced alternation in power, we expect the main opposition parties to be as likely as the dominating party to formulate a counterproposal. We expect a stronger effect as multiparty competition and alternation in power increase (this hypothesis can be tested by stage and/or combining both stages 1 and 2).

//////////////////////////////////////////////////////////////////////////////////////////
H1.3: Alternation in Power (alternation and multiparty competition) --> Comparing the total number of counterporposals at the state level as alternation and multiparty competition increase. 
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis:
# Paries in states with alternetion and multipary competition are more likely to formulate a higher number of counterproposals being formulated than prties in states that are dominated by a single party. 

or 

#As alternation and multipartycompetition incease, more proposals will be formulated.
 
Variables: 
#DV: Total number of counterproposals formulated. Based on the dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a single party ruled that state before redisrticting took place (single_pty_dom_00_17:True or False, by State). 

#IV(2): Categorical variable captruing the degree of alternation in power (six categories from a non-competitive state to a party that has multiparty comptetion and alternation has taken place >3+ times in the 00-17 period): 1) single_pty_dom_00_17:True or False, by State; 2) alt_power1_00_17; 3) alt_power2_00_17; 4) alt_power2_00_17 x multi_comp_00_17; 5) alt_power3_00_17; 6) alt_power3_00_17 x multi_comp_00_17. 

Method: 
#To test H1.1: chi.sq test.

# If the hpothesis is true, we would expect to observe more counterporposals in states with more alternation and multiparty competition.


//////////////////////////////////////////////////////////////////////////////////////////
H2:Party Strenght (Vote Returns) 
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
H2.1: Party Strenght (High vs Low vote returns at the seccion level)--> Comparing interaction under different levels of electoral returns 
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis
# If a party receives a high vote share in a state, it is more likely to formulate a counterproposal than those parties that receive a lower vote share.

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a party has high or low levels of vote returns in a particular state before redisrticting took place (High > 50%, Low <24%). 

#IV(2): Categorical variable capturing the level of vote returns (Five categories: Very High(>75%), High(74%-50%), Medium (49%-25%), Low (24%-15%), Very Low (<14%). 

#IV(3): Continous variable capturing the vote share received by each party at the state level (0-100).

Method:
#To test H2.1: Chisq and Difference of means.

//////////////////////////////////////////////////////////////////////////////////////////
H2.2: Party Competion (High vs Low levels of electoral competition)--> Comparing Interaction under different levels of competition 
//////////////////////////////////////////////////////////////////////////////////////////
Hypotheses
# As competitiveness increases at the state level (e.g., ratio of safe vs competitive districts), we can expect to observe a higher number of counterproposals.

and/or 

# As competitiveness increases (e.g., ratio of safe vs competitive districts), opposition parties are as likely to formulate a conterproposal as the ruling party. 

and/or 

# In a safe state, the ruling party is more likely to formulate a counterproposal than any other party.

and/or

# In a safe state, the main opposition party (secondary force) is as likely a formulate a counterproposal than the ruling party.

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a state con be considered competitive or safe (High > 50%, Low <24%). 

#IV(2): Categorical variable capturing the level of district competitiveness at the state level (Five categories: Very High(>75%), High(74%-50%), Medium (49%-25%), Low (24%-15%), Very Low (<14%). 

#IV(3): Continous variable capturing the level of competitiveness in each district at the state level (0-100).

Method:
#To test H2.2: Chisq and Difference of means.


//////////////////////////////////////////////////////////////////////////////////////////
H2.3: Party Strongholds --> Comparing Interaction assuming parties want to protect strongholds 
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis
# ???? (Still working on this one). It seems this would be district or municipal level analysis to see if parties are protecting strongholds, but not at the entry/state level. 

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a party has high or low levels in a particular state before redisrticting took place (single_pty_dom_00_17:True or False, by State). 

#IV(2): Categorical variable capturing the level of vote returns (Five categories: Very High(>75%), High(74%-50%), Medium (49%-25%), Low (24%-15%), Very Low (<14%). 

Method:
#To test H2.3: Difference of means.

#Comparing parties:.



//////////////////////////////////////////////////////////////////////////////////////////
H3: Coalitions
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
H3.1: Coaltions (Stong and Succesful Coaltion)--> Comparing interaction based on the desission to build state level coalitions.  
//////////////////////////////////////////////////////////////////////////////////////////
Hypothesis
#Smaller parties (not PRI, PAN or PRD) that have a strong and successful coalition with a larger party, are more likely  to formulate a similar counterproposal to its larger coalition mate than smaller parties that competed separately. 

Variables: 
#DV: Dummy variable capturing if party formulated a proposal (PROPOSED: True or False, by Sate, by round, by year).

#IV(1): Dummy variable captruing if a party competed under a coalition before redisrticting took place. 

#IV(2): Dummy variable captruing if a coalition was strong and successful before redisrticting took place. 

Method:
#To test H3.1: Chisq test.

#Comparing parties:.


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
STOP READING HERE
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


#Work in Progress 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Code
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////